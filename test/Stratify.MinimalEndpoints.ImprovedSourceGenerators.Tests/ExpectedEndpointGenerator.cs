using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Stratify.MinimalEndpoints.ImprovedSourceGenerators.Tests;

/// <summary>
/// This is how the EndpointGenerator should work correctly
/// </summary>
public class ExpectedEndpointGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Find all classes that implement IEndpoint
        var endpointImplementations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => IsPotentialEndpoint(s),
                transform: static (ctx, _) => GetEndpointOrNull(ctx))
            .Where(static m => m is not null);

        // Combine and generate
        var compilation = context.CompilationProvider.Combine(endpointImplementations.Collect());

        context.RegisterSourceOutput(compilation,
            static (spc, source) => Execute(source.Left, source.Right!, spc));
    }

    private static bool IsPotentialEndpoint(SyntaxNode node)
    {
        return node is ClassDeclarationSyntax c &&
               c.BaseList != null &&
               !c.Modifiers.Any(SyntaxKind.AbstractKeyword);
    }

    private static EndpointInfo? GetEndpointOrNull(GeneratorSyntaxContext context)
    {
        var classDeclaration = (ClassDeclarationSyntax)context.Node;
        var symbol = context.SemanticModel.GetDeclaredSymbol(classDeclaration);

        if (symbol is null)
        {
            return null;
        }

        // Check if implements IEndpoint
        var implementsIEndpoint = symbol.AllInterfaces
            .Any(i => i.Name == "IEndpoint" &&
                     i.ContainingNamespace.ToDisplayString().Contains("MinimalEndpoints"));

        if (!implementsIEndpoint)
        {
            return null;
        }

        return new EndpointInfo
        {
            Namespace = symbol.ContainingNamespace.ToDisplayString(),
            ClassName = symbol.Name,
            FullTypeName = symbol.ToDisplayString()
        };
    }

    private static void Execute(Compilation compilation, ImmutableArray<EndpointInfo?> endpoints, SourceProductionContext context)
    {
        if (endpoints.IsDefaultOrEmpty)
        {
            return;
        }

        var validEndpoints = endpoints
            .Where(e => e != null)
            .Cast<EndpointInfo>()
            .Distinct(new EndpointInfoComparer())
            .ToList();

        if (!validEndpoints.Any())
        {
            return;
        }

        var source = GenerateEndpointRegistration(validEndpoints);
        context.AddSource("EndpointRegistration.g.cs", SourceText.From(source, Encoding.UTF8));
    }

    private static string GenerateEndpointRegistration(List<EndpointInfo> endpoints)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using Microsoft.AspNetCore.Builder;");
        sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
        sb.AppendLine("using System.Reflection;");
        sb.AppendLine("using System.Linq;");
        sb.AppendLine("using Stratify.MinimalEndpoints;");
        sb.AppendLine();
        sb.AppendLine("namespace Stratify.MinimalEndpoints.Generated;");
        sb.AppendLine();
        sb.AppendLine("public static class EndpointRegistration");
        sb.AppendLine("{");
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Registers all endpoints that implement IEndpoint from the specified assembly");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public static IServiceCollection AddEndpoints(this IServiceCollection services, Assembly assembly)");
        sb.AppendLine("    {");
        sb.AppendLine("        var endpointTypes = assembly.GetTypes()");
        sb.AppendLine("            .Where(t => t.IsClass && !t.IsAbstract && typeof(IEndpoint).IsAssignableFrom(t));");
        sb.AppendLine();
        sb.AppendLine("        foreach (var endpointType in endpointTypes)");
        sb.AppendLine("        {");
        sb.AppendLine("            services.AddScoped(typeof(IEndpoint), endpointType);");
        sb.AppendLine("            services.AddScoped(endpointType);");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        return services;");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Maps all registered endpoints");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public static WebApplication MapEndpoints(this WebApplication app)");
        sb.AppendLine("    {");
        sb.AppendLine("        var endpoints = app.Services.GetServices<IEndpoint>();");
        sb.AppendLine("        foreach (var endpoint in endpoints)");
        sb.AppendLine("        {");
        sb.AppendLine("            endpoint.MapEndpoint(app);");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        return app;");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Gets all endpoint types discovered at compile time");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public static Type[] GetDiscoveredEndpointTypes()");
        sb.AppendLine("    {");
        sb.AppendLine("        return new[]");
        sb.AppendLine("        {");

        foreach (var endpoint in endpoints)
        {
            sb.AppendLine($"            typeof({endpoint.FullTypeName}),");
        }

        sb.AppendLine("        };");
        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }

    private sealed class EndpointInfo
    {
        public string Namespace { get; set; } = "";
        public string ClassName { get; set; } = "";
        public string FullTypeName { get; set; } = "";
    }

    private sealed class EndpointInfoComparer : IEqualityComparer<EndpointInfo>
    {
        public bool Equals(EndpointInfo? x, EndpointInfo? y)
        {
            if (ReferenceEquals(x, y)) return true;
            if (x is null || y is null) return false;
            return x.FullTypeName == y.FullTypeName;
        }

        public int GetHashCode(EndpointInfo obj)
        {
            return obj.FullTypeName.GetHashCode();
        }
    }
}
